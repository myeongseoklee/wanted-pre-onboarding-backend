# wanted-pre-onboarding-backend

다양한 기업의 기술과제를 수행하는 교육형 인턴십 '원티드 프리온보딩 백엔드 인턴쉽'에 참여하기 위한 사전과제 레포지토리입니다.

---

## 코딩 컨벤션

- 디렉토리 및 파일 이름은 nest의 기본 컨벤션(케밥케이스)을 사용하였습니다. 아키텍처가 복잡해질 경우 카멜 케이스 보다 케밥 케이스의 가독성이 좋다고 판단했습니다.

- 함수와 변수의 이름은 카멜 케이스를, 인터페이스, 생성자, 타입, Enum의 변수명은 파스칼 케이스, 상수(constant)는 대문자 스네이크 케이스를 사용하였습니다.

- 변수명이 길더라도 명확한 의미 전달을 위해 약어를 사용하지 않았습니다.

## 프로젝트 구성

### Stack

- Typescript, Nest.js(Express), TypeORM(MySQL), Jest

### Architecture

-

### Class Diagram

---

## 기능목록

### 1. 채용공고 등록

- 채용공고 data

  > - 필수 사항 : 직군(jobGroup)/직무(job), 경력(experienceYears), 근무지(workingArea), 자격요건(qualifications), 혜택 및 복지(benefits), 주요 업무(tasks), 공고마감일(deadline)
  > - 선택 사항 : 우대사항(preferenceQualifications), 사용기술(technologyStacks)

- 하나의 회사(company)는 여러개의 채용공고(recruitment-notice)를 등록할 수 있어야 하기 때문에, 회사(id)와 채용공고(id)의 관계를 일대다로 설정했습니다.

- 근무지(workingArea) 필드의 경우 올바른 주소를 저장하기 위한 검증이 필요합니다. 따라서 외부 api(ex. kakao)를 활용해 주소 값을 가져오는 방식을 사용합니다. (코드 구현은 하지 않았습니다)

### 2. 채용공고 수정

- 수정할 공고id는 path parameter로 받습니다. 하나의 채용공고에는 많은 데이터가 담기므로, 수정 할 데이터만 request body로 받아서 수정 로직을 구현했습니다.

### 3. 채용공고 삭제

- 채용 공고삭제 이력도 관리해야 할 데이터라고 생각하여 soft delete 방식으로 구현했습니다.

- 채용공고가 삭제되면 회사는 지원자(job-seeker) 정보를 더 이상 조회할 수 없어야 하고, 구직자는 자신이 어떤 회사에 지원했는지 지원 이력은 확인 가능해야 합니다.

### 4. 채용공고 목록 조회

- 채용공고 목록은 request query parameter를 활용하여 직군(jobGroup)과 직무(job), 근무지(workingArea), 기술스택(technologyStacks)을 기준으로 필터링할 수 있으며 최신순으로 정렬됩니다. 마감일이 종료된 공고는 조회되지 않습니다.

- 또한, 필터링된 데이터 내에서 채용공고를 검색할 수 있습니다.

- 채용공고 목록은 1회 요청 당 20개의 채용공고를 조회할 수 있으며, api요청 시 요청 페이지 number를 함께 받습니다. 응답으로 채용공고 목록과 함께 전체 페이지의 수를 응답으로 제공합니다. 전체 페이지 수보다 큰 값을 조회 요청 페이지 값으로 전달하는 경우 더이상 추가로 조회 가능한 요청이 없다는 메시지를 반환합니다. 따라서 프론트엔드에서는 페이지네이션을 무한스크롤로도 구현할 수 있고, 전체 페이지가 몇 개인지 알 수 있기 때문에 일반 게시판처럼 페이지 번호를 해당 페이지의 데이터를 안정적으로 요청할 수도 있습니다.

### 5. 채용 상세페이지 조회

- 회사가 올린 다른 채용 공고를 추가적으로 포함하는 방법은 채용 상세 정보 조회 쿼리에 포함하여 한 번에 가져오는 방법과, 상세 정보를 가져온 후, 별도로 채용공고 목록을 가져와 서비스단에서 데이터를 붙이는 방법이 있습니다. 전자의 방법은 RDBMS의 JOIN과 SUBQUERY를 사용하면 됩니다. 하지만, 기존의 채용 목록 조회 api에서 사용한 코드를 재활용할 수 있고, 회사가 올린 다른 채용공고를 보여주는 요구사항이 '이 공고와 유사한 채용 공고'를 보여주는 요구사항으로 변화했을때 대응이 수월할 것 같다는 점. 그리고 채용 목록 조회 api에서 제공하는 데이터로도 충분할 것으로 예상되므로 후자의 방식으로 구현했습니다.

### 6. 채용 공고 지원

- 하나의 채용공고(recruitment-notice)는 여러명의 구직자의 지원서를 받을 수 있고, 구직자(job-seeker)는 여러개의 채용공고에 지원할 수 있습니다. 따라서 구직자(id)와 채용공고(id)의 관계를 다대다로 설정하는 것이 좋습니다. typeORM에서 지원하는 @JoinTable로 연결 테이블을 생성할 수 있지만 다음과 같은 문제로 이 기능을 사용하지 않고 별도의 엔티티(jobApply)를 생성하여 각각 일대다, 다대일 관계를 맺었습니다.

> - 연결 테이블은 매핑 정보만 컬럼으로 가질수 있다는 한계가 있습니다. jobApply 테이블에는 지원 상태(statement) 값이 저장되어야 하며 이외에도 지원 시간, 상태(statement)변화 시간 등 컬럼을 추가할 가능성이 높습니다.
> - 구직자와 채용 공고의 관계(relation)는 '지원'의 관계로도 묶일 수 있지만 '스크랩, 좋아요'등의 기능으로도 묶일 수 있으므로 가상의 연결테이블 보다 엔티티를 활용하는 것이 좋다고 생각합니다.

- 구직자는 하나의 채용공고에 1회만 지원 가능하므로, jobApply 테이블에서 구직자\_id 컬럼과 채용공고\_id 컬럼을 한 쌍으로 unique key 제약을 설정했습니다.
